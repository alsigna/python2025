# Многозадачность

- [Многозадачность](#многозадачность)
  - [Описание](#описание)
  - [Последовательное / конкурентное / параллельное выполнение](#последовательное--конкурентное--параллельное-выполнение)
  - [CPU-bound / IO-bound](#cpu-bound--io-bound)
  - [IO-bound](#io-bound)
  - [Асинхронное программирование](#асинхронное-программирование)
  - [Кооперативная и вытесняющая многозадачность](#кооперативная-и-вытесняющая-многозадачность)
  - [GIL](#gil)
  - [Реализация в Python](#реализация-в-python)

## Описание

Многозадачность - свойство операционной системы обеспечивать возможность одновременной обработки нескольких задач.

Есть два вида многозадачности:

- процессная
- поточная

Процессная многозадачность основана на процессах. Процесс это независимый экземпляр программы. У каждого процесса свое собственного адресное пространство в памяти и свои собственные ресурсы. Можно рассматривать процессную многозадачность как просто запуск еще одной копии программы. Процессы не связаны между собой и могут работать независимо.

Потоковая многозадачность основана на потоках в рамках одного процесса. Поток выполняет какую-то свою отдельную подзадачу в рамках одной программы. Потоки, как часть одного процесса, разделяют общее адресное пространство и имеют общий доступ к ресурсам процесса (память, файлы и пр).

У каждой программы есть как минимум один процесс, а у каждого процесса есть как минимум один поток.

## Последовательное / конкурентное / параллельное выполнение

Последовательное выполнение (sequential) это выполнение инструкций кода по очереди одну за одной, весь рассматриваемый ранее в примерах код был последовательным.

Конкурентное выполнение (concurrent) это одновременное выполнение некоторого числа задач за единицу времени. При этом термин не фиксирует как именно будет достигнута одновременность выполнения, это может быть реализовано за счет приостановки одних задач и выполнения в этот момент других, а может быть за счет использования нескольких вычислительных ресурсов.

Параллельное выполнение (parallelism) уточняет конкурентное в плане подхода, явно фиксируя, что для задачи будут выполняться на разных вычислительных ресурсах.

## CPU-bound / IO-bound

Операции можно условно разделить на блокирующие и не блокирующие.

Неблокирующие операции работают только с CPU и зачастую занимаются вычислениями, сильно нагружают CPU, а скорость их выполнения зависит от возможностей самого CPU.

Блокирующие операции это операции связанные с ожиданием информации от какой-либо внешней системы/ресурса. Например ввод с клавиатуры, чтение файлов, консольный вывод или ответ от сетевого устройства.

Операции, связанные только с работой CPU называют CPU-bound и они в основном выполняют неблокирующие операции.
Операции, связанные с подсистемой ввода/вывода называют IO-bound и они в основном выполняют блокирующие операции.

Взаимодействие с сетевым оборудование относится к IO-bound операциям, поэтому рассматриваем только особенности этого типа.

## IO-bound

IO-bound операции для последовательного вычисления выглядят следующим образом

<p align="center"><img src="img/sequential.png" width="500" alt=""></p>

Ожидание ответа блокирует выполнение программы и общее время выполнения сильно увеличивается, но при этого время полезной работы (вычислений) может сильно уступать времени простоя.

Выполнение таких задач можно ускорить, если выделить каждую блокирующую задачу в отдельный поток.

<p align="center"><img src="img/threaded.png" width="500" alt=""></p>

Длительность выполнения в таком случае сильно сокращается, так как запросы инициируются практически одновременно разными потоками.

## Асинхронное программирование

Это способ организации многозадачности, который позволяет эффективно управлять ресурсами и увеличить производительность.

За создание потоков отвечает операционная система и это достаточно ресурсозатратный процесс (выделяются дескрипторы, планировщик начинает следить и управлять всем потоками и пр.). И при этом все равно в рамках одного потока будет простой по времени, пока программа ожидает ответа от внешнего источника.

Как альтернатива потокам существует асинхронный подход к такому рода задач. В этом походе код выполняется в одном потоке, но переключение между подзадачами все равно происходит за счет внутреннего планировщика по мере перехода подзадачи в режим ожидания. Т.е. управлением использования процессорным временем занимается не планировщик операционной системы, а внутренний планировщик python. Для операционной системы такая программа остается однопоточной.

<p align="center"><img src="img/async.png" width="500" alt=""></p>

## Кооперативная и вытесняющая многозадачность

В кооперативной многозадачности задачи самостоятельно принимают решение о том, когда им следует передать контроль над ресурсами другим задачам. Это означает, что каждая задача должна уметь активно делиться ресурсами с другими задачами, что бы они могли выполнятся. Места передачи управления определяются разработчиком с помощью специальных синтаксических конструкций.

В вытесняющей многозадачности решение о том, когда задаче следует начать/прекратить выполнение определяется операционной системой. ОС через прерывания распределяет процессорное время между задачами, моменты передачи управления другим задачам от разработчика не зависят.

## GIL

Global Interpreter Lock предотвращает выполнение нескольких потоков в одно и то же время. Все потоки конкурируют за GIL, чтобы получить доступ к исполнению кода. GIL создан для обеспечения безопасности многопоточной работы в CPython.

Особенность GIL в том, что поток блокирует GIL только на то время, когда происходит изменения python-объектов и освобождается во время IO операций или некоторых функций (например time.sleep). Этот факт делает возможным значительное ускорение программы при использовании многопоточности для IO операций.

Варианты обойти GIL:

- использовать многопроцессность, тогда у каждого процесса будет свой GIL и они будут работать независимо
- использовать модули, написанные на C, в них есть возможность явно освободить GIL, поэтому тяжелые вычисления (CPU-bound) лучше делать через numpy/pandas, которые написаны на C и обходят ограничения GIL

## Реализация в Python

В Python описанные подходы реализуются соответствующими встроенными библиотеками

- многопоточность: `threading`
- многопроцессность: `multiprocessing`
- асинхронность: `asyncio`

С учетом GIL можно получить такие правила:

- многопоточность: `threading`, конкурентное выполнение CPU-bound и IO-bound операций (но для CPU-bound выгоды в скорости не будет)
- многопроцессность: `multiprocessing`, параллельное выполнения CPU-bound операций
- асинхронность: `asyncio`, кооперативное выполнение IO-bound операций в одном потоке

В теории для IO-bound операций (а обращение к сетевым устройствам это IO-bound) можно сказать, что асинхронный подход может быть более предпочтителен так как обращений много и ответ от устройств медленный, поэтому потоки будут использоваться не рационально. Но на практике стоит учитывать, что асинхронный код намного сложнее последовательного (который в свою очередь достаточно просто перекладывается в потоки), а так же асинхронная работа поддерживается не всеми библиотеками.

> GIL - плата за простоту и безопасность python. Разработчику не нужно заботиться о проблемах, связанных с общими ресурсами (гонки, коллизии, блокировки и прочее). Обойти GIL можно если использовать многопроцессность, или другую реализацию Python, например Jpython вместо CPython, или использовать С/С++ скомпилированные библиотеки (numpy, tensorflow, или написать свои).

[threading vs multiprocessing in python](https://www.youtube.com/watch?v=AZnGRKFUU0c)  
[GIL на habr.com](https://habr.com/ru/companies/wunderfund/articles/586360/)
